name: Build and Publish to AUR

on:
  schedule:
    # Run daily at 00:00 UTC
    - cron: '0 0 * * *'
  push:
    branches:
      - main
    paths:
      - 'pkgs/*/PKGBUILD'
  workflow_dispatch:
    inputs:
      package:
        description: 'Specific package (leave empty for all)'
        required: false
        type: string
      force:
        description: 'Force update even if version unchanged'
        required: false
        type: boolean
        default: false
      skip_publish:
        description: 'Skip AUR publishing (dry-run)'
        required: false
        type: boolean
        default: false

permissions:
  contents: write

jobs:
  check-and-prepare:
    runs-on: ubuntu-latest
    outputs:
      packages: ${{ steps.determine.outputs.packages }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Install dependencies
        if: github.event_name != 'push'
        run: |
          sudo apt-get update
          sudo apt-get install -y curl jq

      - name: Determine packages to build
        id: determine
        run: |
          set -euo pipefail

          if [[ "${{ github.event_name }}" == "push" ]]; then
            # Push trigger: detect changed packages
            changed_files=$(git diff --name-only HEAD^ HEAD || git diff --name-only HEAD)
            packages=$(echo "${changed_files}" | grep -E '^pkgs/[^/]+/(PKGBUILD|\.SRCINFO)$' | cut -d'/' -f2 | sort -u | jq -R -s -c 'split("\n")[:-1]')
            echo "packages=${packages}" >> "${GITHUB_OUTPUT}"
            echo "Push trigger: building changed packages: ${packages}"
            exit 0
          fi

          # Schedule or manual trigger: check upstream updates
          if [[ -n "${{ github.event.inputs.package }}" ]]; then
            all_packages='["${{ github.event.inputs.package }}"]'
          else
            all_packages=$(find pkgs -mindepth 1 -maxdepth 1 -type d -exec basename {} \; | sort | jq -R -s -c 'split("\n")[:-1]')
          fi

          force_flag=""
          if [[ "${{ github.event.inputs.force }}" == "true" ]]; then
            force_flag="--force"
          fi

          updated_packages=()

          for pkg in $(echo "${all_packages}" | jq -r '.[]'); do
            echo "Checking ${pkg}..."
            if scripts/update-package.sh "${pkg}" ${force_flag}; then
              if git diff --quiet "pkgs/${pkg}/PKGBUILD" 2>/dev/null; then
                echo "No changes detected for ${pkg}"
              else
                echo "Updates detected for ${pkg}"
                updated_packages+=("${pkg}")
              fi
            else
              echo "Failed to check ${pkg}" >&2
            fi
          done

          if [[ ${#updated_packages[@]} -eq 0 ]]; then
            echo "No package updates found"
            echo "packages=[]" >> "${GITHUB_OUTPUT}"
            exit 0
          fi

          # Regenerate README with updated package versions
          echo "Regenerating README files..."
          bash scripts/build-readme.sh

          # Commit updates
          for pkg in "${updated_packages[@]}"; do
            git add "pkgs/${pkg}/PKGBUILD"
            new_version=$(awk -F'= *' '$1=="pkgver"{print $2; exit}' "pkgs/${pkg}/PKGBUILD")
            git add README.md README.zh.md docs/readme.en.md 2>/dev/null || true
            git commit -m "ci: update ${pkg} to ${new_version}

          Automated upstream version detection.

          Co-Authored-By: github-actions[bot] <github-actions[bot]@users.noreply.github.com>"
          done

          # Pull before push to avoid conflicts
          if ! git pull --rebase origin main; then
            echo "Failed to rebase, attempting merge" >&2
            git rebase --abort || true
            git pull --no-rebase origin main
          fi

          git push origin main

          echo "Successfully committed updates for: ${updated_packages[*]}"

          # Output updated packages
          packages_json=$(printf '%s\n' "${updated_packages[@]}" | jq -R -s -c 'split("\n")[:-1]')
          echo "packages=${packages_json}" >> "${GITHUB_OUTPUT}"

      - name: Upload logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: check-logs-${{ github.run_id }}
          path: |
            *.log
          retention-days: 30
          if-no-files-found: ignore

  build-and-validate:
    needs: check-and-prepare
    if: needs.check-and-prepare.outputs.packages != '[]'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        package: ${{ fromJson(needs.check-and-prepare.outputs.packages) }}
      fail-fast: false
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Build and validate package
        uses: heyhusen/archlinux-package-action@v2
        with:
          path: pkgs/${{ matrix.package }}
          flags: '-s --noconfirm'
          namcap: true
          srcinfo: true

      - name: Upload build logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.package }}-logs-${{ github.run_id }}
          path: |
            pkgs/${{ matrix.package }}/*.log
            pkgs/${{ matrix.package }}/src/
          retention-days: 30
          if-no-files-found: ignore

  publish-to-aur:
    needs: [check-and-prepare, build-and-validate]
    if: needs.check-and-prepare.outputs.packages != '[]' && github.event.inputs.skip_publish != 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        package: ${{ fromJson(needs.check-and-prepare.outputs.packages) }}
      fail-fast: false
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Generate .SRCINFO
        run: |
          pkg_dir="pkgs/${{ matrix.package }}"
          echo "Generating .SRCINFO for ${{ matrix.package }}..."
          docker run --rm \
            -v "$(pwd)/${pkg_dir}:/pkg" \
            -w /pkg \
            archlinux:latest \
            bash -c "
              pacman -Sy --noconfirm base-devel && \
              useradd -m builder && \
              chown -R builder:builder /pkg && \
              su - builder -c 'cd /pkg && makepkg --printsrcinfo > .SRCINFO'
            "

          if [[ ! -f "${pkg_dir}/.SRCINFO" ]]; then
            echo "Failed to generate .SRCINFO"
            exit 1
          fi
          echo ".SRCINFO generated successfully"

      - name: Get package version
        id: pkgver
        run: |
          pkg_dir="pkgs/${{ matrix.package }}"
          pkgver=$(awk -F'= *' '$1=="pkgver"{print $2; exit}' "${pkg_dir}/PKGBUILD")
          echo "version=${pkgver}" >> "${GITHUB_OUTPUT}"

      - name: Prepare assets list
        id: assets
        run: |
          pkg_dir="pkgs/${{ matrix.package }}"
          assets="${pkg_dir}/.SRCINFO"

          shopt -s nullglob
          for pattern in "*.install" "*.patch" "*.sh" "*.service"; do
            for file in "${pkg_dir}"/${pattern}; do
              if [[ -f "${file}" ]]; then
                assets="${assets}"$'\n'"${file}"
              fi
            done
          done

          {
            echo "list<<EOF"
            echo "${assets}"
            echo "EOF"
          } >> "${GITHUB_OUTPUT}"

      - name: Publish to AUR
        uses: KSXGitHub/github-actions-deploy-aur@v2.7.0
        with:
          pkgname: ${{ matrix.package }}
          pkgbuild: pkgs/${{ matrix.package }}/PKGBUILD
          commit_username: github-actions[bot]
          commit_email: github-actions[bot]@users.noreply.github.com
          ssh_private_key: ${{ secrets.AUR_SSH_KEY }}
          ssh_keyscan_types: rsa,ecdsa,ed25519
          commit_message: |
            Update to ${{ steps.pkgver.outputs.version }}

            Automated build and publish via GitHub Actions.

            Co-Authored-By: github-actions[bot] <github-actions[bot]@users.noreply.github.com>
          assets: ${{ steps.assets.outputs.list }}
